<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A Arena - Serpente Futurista</title>
    <style>
        /* Reset e Estilos Gerais */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #0a0a1a;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Tela de Loading Futurista */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000011;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        .loading-logo {
            font-size: 48px;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            margin-bottom: 30px;
            letter-spacing: 3px;
            animation: pulse 2s infinite;
        }
        
        .loading-bar-container {
            width: 300px;
            height: 10px;
            background-color: rgba(0, 100, 150, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0066ff, #00ccff);
            box-shadow: 0 0 10px #00ccff;
            transition: width 0.3s ease;
            border-radius: 5px;
        }
        
        .loading-text {
            color: #aaffff;
            font-size: 18px;
            text-shadow: 0 0 5px #00ffff;
        }
        
        /* Menu Principal */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 30, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        
        .menu-title {
            color: #00ffff;
            font-size: 48px;
            text-shadow: 0 0 15px #00ffff;
            margin-bottom: 50px;
            letter-spacing: 3px;
            text-align: center;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 300px;
            max-width: 90%;
        }
        
        .menu-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: linear-gradient(to bottom, #00ccff, #0066ff);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px #0066ff;
            text-align: center;
        }
        
        .menu-btn:hover {
            background: linear-gradient(to bottom, #ff00cc, #cc00ff);
            box-shadow: 0 0 25px #cc00ff;
            transform: scale(1.05);
        }
        
        /* Jogo */
        #game-container {
            position: relative;
            display: none;
            width: 100%;
            height: 100%;
            max-width: 700px;
            max-height: 700px;
        }
        
        #game-canvas {
            border: 4px solid #2a2a4a;
            border-radius: 8px;
            box-shadow: 0 0 40px #3a3a8a;
            width: 100%;
            height: 100%;
        }
        
        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 18px;
            color: #aaffff;
            text-shadow: 0 0 8px #00ffff;
            background-color: rgba(10, 10, 30, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 5;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 30, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #game-over h1 {
            color: #ff5555;
            font-size: 48px;
            text-shadow: 0 0 15px #ff0000;
            margin-bottom: 30px;
            text-align: center;
        }
        
        #game-over p {
            font-size: 24px;
            margin: 10px 0;
            color: #aaffff;
            text-align: center;
        }
        
        #restart-btn {
            margin-top: 30px;
            padding: 12px 25px;
            font-size: 20px;
            background: linear-gradient(to bottom, #00ccff, #0066ff);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px #0066ff;
        }
        
        #restart-btn:hover {
            background: linear-gradient(to bottom, #ff00cc, #cc00ff);
            box-shadow: 0 0 25px #cc00ff;
            transform: scale(1.05);
        }
        
        #difficulty-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 16px;
            color: #55ff55;
            background-color: rgba(10, 10, 30, 0.7);
            padding: 8px;
            border-radius: 5px;
            z-index: 5;
            max-width: 80%;
        }
        
        /* Controles para Mobile */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: center;
            z-index: 5;
        }
        
        .mobile-controls-container {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 10px;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 100, 200, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            border: 2px solid rgba(0, 200, 255, 0.3);
        }
        
        .mobile-btn:active {
            background-color: rgba(0, 150, 255, 0.8);
        }
        
        #up-btn { grid-area: up; }
        #left-btn { grid-area: left; }
        #right-btn { grid-area: right; }
        #down-btn { grid-area: down; }
        
        /* Animações */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        /* Opções de Dificuldade */
        #difficulty-options {
            display: none;
            flex-direction: column;
            gap: 15px;
            width: 300px;
            max-width: 90%;
            margin-top: 30px;
        }
        
        .difficulty-btn {
            padding: 12px 20px;
            font-size: 18px;
            background: rgba(0, 100, 150, 0.3);
            color: white;
            border: 1px solid #00aaff;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .difficulty-btn:hover {
            background: rgba(0, 150, 200, 0.5);
            box-shadow: 0 0 15px #00aaff;
        }
        
        .difficulty-btn.selected {
            background: linear-gradient(to bottom, #00ccff, #0066ff);
            box-shadow: 0 0 15px #0066ff;
            border: 1px solid #00ffff;
        }
        
        .back-btn {
            margin-top: 20px;
            padding: 10px 15px;
            font-size: 16px;
            background: transparent;
            color: #aaffff;
            border: 1px solid #aaffff;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .back-btn:hover {
            background: rgba(170, 255, 255, 0.1);
            box-shadow: 0 0 10px #aaffff;
        }
        
        /* Ajustes para mobile */
        @media (max-width: 768px) {
            .menu-title {
                font-size: 36px;
                margin-bottom: 30px;
            }
            
            .menu-btn {
                padding: 12px 20px;
                font-size: 18px;
            }
            
            #game-over h1 {
                font-size: 36px;
            }
            
            #game-over p {
                font-size: 20px;
            }
            
            #restart-btn {
                font-size: 18px;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Tela de Loading -->
    <div id="loading-screen">
        <div class="loading-logo">A ARENA</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        <div class="loading-text" id="loading-text">Inicializando sistemas...</div>
    </div>
    
    <!-- Menu Principal -->
    <div id="main-menu">
        <h1 class="menu-title">A ARENA</h1>
        <div class="menu-options">
            <button class="menu-btn" id="start-game-btn">INICIAR JOGO</button>
            <button class="menu-btn" id="difficulty-btn">DIFICULDADE</button>
            <button class="menu-btn" id="instructions-btn">INSTRUÇÕES</button>
        </div>
        
        <!-- Opções de Dificuldade -->
        <div id="difficulty-options">
            <button class="difficulty-btn selected" data-speed="1.5">RELAX (Fácil)</button>
            <button class="difficulty-btn" data-speed="2.5">NORMAL</button>
            <button class="difficulty-btn" data-speed="3.5">DESAFIO (Difícil)</button>
            <button class="difficulty-btn" data-speed="5">EXTREMO</button>
            <button class="back-btn" id="back-btn">VOLTAR</button>
        </div>
    </div>
    
    <!-- Jogo -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="hud">
            <div>Pontos: <span id="score">0</span></div>
            <div>Nível: <span id="level">1</span></div>
            <div id="invincible-timer" style="color: #ffff00; display: none;">Escudo: <span id="invincible-time">5.0</span>s</div>
        </div>
        
        <div id="difficulty-info">MODO RELAX: Velocidade reduzida e movimentos suaves</div>
        
        <!-- Controles Mobile -->
        <div id="mobile-controls">
            <div class="mobile-controls-container">
                <div class="mobile-btn" id="up-btn">↑</div>
                <div class="mobile-btn" id="left-btn">←</div>
                <div class="mobile-btn" id="right-btn">→</div>
                <div class="mobile-btn" id="down-btn">↓</div>
            </div>
        </div>
        
        <div id="game-over">
            <h1>FIM DE JOGO</h1>
            <p>Pontuação Final: <span id="final-score">0</span></p>
            <p>Nível Alcançado: <span id="final-level">1</span></p>
            <button id="restart-btn">Jogar Novamente</button>
        </div>
    </div>

    <!-- Sons -->
    <audio id="level-up-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" type="audio/mpeg">
    </audio>

    <audio id="special-food-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3" type="audio/mpeg">
    </audio>

    <audio id="menu-select-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Elementos do DOM
        const loadingScreen = document.getElementById('loading-screen');
        const loadingBar = document.getElementById('loading-bar');
        const loadingText = document.getElementById('loading-text');
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.getElementById('game-container');
        const startGameBtn = document.getElementById('start-game-btn');
        const difficultyBtn = document.getElementById('difficulty-btn');
        const instructionsBtn = document.getElementById('instructions-btn');
        const difficultyOptions = document.getElementById('difficulty-options');
        const backBtn = document.getElementById('back-btn');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const invincibleTimer = document.getElementById('invincible-timer');
        const invincibleTimeElement = document.getElementById('invincible-time');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const finalLevelElement = document.getElementById('final-level');
        const restartBtn = document.getElementById('restart-btn');
        const difficultyInfo = document.getElementById('difficulty-info');
        const mobileControls = document.getElementById('mobile-controls');
        const upBtn = document.getElementById('up-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const downBtn = document.getElementById('down-btn');
        
        const levelUpSound = document.getElementById('level-up-sound');
        const specialFoodSound = document.getElementById('special-food-sound');
        const menuSelectSound = document.getElementById('menu-select-sound');
        
        // Constantes do jogo
        const GRID_SIZE = 25;
        const TICK_RATE_BASE = 300;
        const ARENA_SIZE_BASE = 20;
        const SPECIAL_FOOD_INTERVAL = 4;
        
        // Cores da cobra por nível
        const SNAKE_COLORS = [
            { primary: '#00aaff', secondary: '#00ffff' },
            { primary: '#00ffaa', secondary: '#00ff88' },
            { primary: '#aa00ff', secondary: '#cc00ff' },
            { primary: '#ffaa00', secondary: '#ffcc00' },
            { primary: '#ff00aa', secondary: '#ff0088' },
            { primary: '#ffffff', secondary: '#cccccc' }
        ];
        
        // Cores para animação de level up
        const LEVEL_UP_COLORS = [
            '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
            '#ff8800', '#ff0088', '#8800ff', '#00ff88', '#0088ff', '#88ff00'
        ];
        
        // Tipos de comida futuristas
        const FOOD_TYPES = [
            { 
                color: '#00ff88', 
                glow: '#00ffaa',
                points: 10, 
                effect: 'grow', 
                size: 10, 
                name: 'Energia' 
            },
            { 
                color: '#0088ff', 
                glow: '#00aaff',
                points: 15, 
                effect: 'speed_up', 
                size: 9, 
                name: 'Turbo' 
            },
            { 
                color: '#ffcc00', 
                glow: '#ffee00',
                points: 20, 
                effect: 'invincible', 
                size: 12, 
                name: 'Escudo' 
            },
            { 
                color: '#ff00ff', 
                glow: '#ff00cc',
                points: 50, 
                effect: 'shrink', 
                size: 15, 
                name: 'Redutor', 
                special: true 
            }
        ];
        
        // Variáveis do jogo
        let snake = [];
        let snakeSegments = [];
        let direction = 'RIGHT';
        let nextDirection = 'RIGHT';
        let food = [];
        let score = 0;
        let level = 1;
        let speed = 1.5; // Valor padrão (Relax)
        let gameLoop;
        let lastTickTime = 0;
        let invincible = false;
        let invincibleEndTime = 0;
        let gameActive = false;
        let arenaSize = ARENA_SIZE_BASE;
        let currentSnakeColor = SNAKE_COLORS[0];
        let isLevelUpAnimation = false;
        let levelUpAnimationEndTime = 0;
        let levelUpColorIndex = 0;
        let levelUpAnimationInterval;
        let specialFoodActive = false;
        let lastSpecialFoodLevel = 0;
        let isMobile = false;
        let canvasSize = 700;
        
        // Detecta se é mobile e ajusta o tamanho do canvas
        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                canvasSize = Math.min(window.innerWidth, window.innerHeight) * 0.9;
                mobileControls.style.display = 'flex';
            } else {
                canvasSize = 700;
                mobileControls.style.display = 'none';
            }
            
            canvas.width = canvasSize;
            canvas.height = canvasSize;
        }
        
        // Simula o carregamento
        function simulateLoading() {
            detectMobile();
            
            let progress = 0;
            const loadingMessages = [
                "Inicializando sistemas...",
                "Carregando módulos gráficos...",
                "Preparando ambiente...",
                "Sincronizando rede...",
                "Pronto para iniciar!"
            ];
            
            const interval = setInterval(() => {
                progress += Math.random() * 10 + 5;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    
                    // Atualiza a barra e texto final
                    loadingBar.style.width = `${progress}%`;
                    loadingText.textContent = loadingMessages[4];
                    
                    // Esconde a tela de loading e mostra o menu
                    setTimeout(() => {
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                            showMainMenu();
                        }, 1000);
                    }, 500);
                } else {
                    loadingBar.style.width = `${progress}%`;
                    
                    // Atualiza mensagem baseado no progresso
                    const messageIndex = Math.min(
                        Math.floor(progress / 25),
                        loadingMessages.length - 2
                    );
                    loadingText.textContent = loadingMessages[messageIndex];
                }
            }, 300);
        }
        
        // Mostra o menu principal
        function showMainMenu() {
            mainMenu.style.display = 'flex';
            playMenuSound();
        }
        
        // Esconde o menu principal
        function hideMainMenu() {
            mainMenu.style.display = 'none';
        }
        
        // Mostra opções de dificuldade
        function showDifficultyOptions() {
            mainMenu.querySelector('.menu-options').style.display = 'none';
            difficultyOptions.style.display = 'flex';
            playMenuSound();
        }
        
        // Esconde opções de dificuldade
        function hideDifficultyOptions() {
            difficultyOptions.style.display = 'none';
            mainMenu.querySelector('.menu-options').style.display = 'flex';
            playMenuSound();
        }
        
        // Toca som de seleção no menu
        function playMenuSound() {
            menuSelectSound.currentTime = 0;
            menuSelectSound.play();
        }
        
        // Seleciona dificuldade
        function selectDifficulty(btn) {
            difficultyBtns.forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            
            speed = parseFloat(btn.dataset.speed);
            
            // Atualiza texto informativo
            let difficultyText = "";
            switch (speed) {
                case 1.5: difficultyText = "MODO RELAX: Velocidade reduzida e movimentos suaves"; break;
                case 2.5: difficultyText = "MODO NORMAL: Velocidade padrão para desafio equilibrado"; break;
                case 3.5: difficultyText = "MODO DESAFIO: Alta velocidade para jogadores experientes"; break;
                case 5: difficultyText = "MODO EXTREMO: Apenas para os melhores pilotos da serpente"; break;
            }
            difficultyInfo.textContent = difficultyText;
            
            playMenuSound();
        }
        
        // Inicializa o jogo
        function initGame() {
            // Inicializa a cobra
            snake = [
                {x: 10, y: 10, angle: 0},
                {x: 9, y: 10, angle: 0},
                {x: 8, y: 10, angle: 0}
            ];
            
            snakeSegments = JSON.parse(JSON.stringify(snake));
            
            direction = 'RIGHT';
            nextDirection = 'RIGHT';
            score = 0;
            level = 1;
            gameActive = true;
            arenaSize = ARENA_SIZE_BASE;
            invincible = false;
            invincibleTimer.style.display = 'none';
            currentSnakeColor = SNAKE_COLORS[0];
            isLevelUpAnimation = false;
            specialFoodActive = false;
            lastSpecialFoodLevel = 0;
            
            // Cria comida inicial
            createFood();
            
            // Atualiza HUD
            updateHUD();
            
            // Esconde menu e mostra jogo
            hideMainMenu();
            hideDifficultyOptions();
            gameOverScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            
            // Mostra controles mobile se necessário
            if (isMobile) {
                mobileControls.style.display = 'flex';
            }
            
            // Inicia o loop do jogo
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(gameTick, TICK_RATE_BASE / speed);
            
            // Inicia animação suave
            requestAnimationFrame(smoothRender);
        }
        
        // Cria nova comida
        function createFood() {
            const now = Date.now();
            food = food.filter(f => !f.expires || f.expires > now);
            
            // Verifica se deve criar comida especial
            if (!specialFoodActive && level >= lastSpecialFoodLevel + SPECIAL_FOOD_INTERVAL && level % SPECIAL_FOOD_INTERVAL === 0) {
                const specialFoodType = FOOD_TYPES.find(f => f.special);
                
                let newFood;
                let validPosition = false;
                
                while (!validPosition) {
                    newFood = {
                        x: Math.floor(Math.random() * arenaSize),
                        y: Math.floor(Math.random() * arenaSize),
                        type: specialFoodType,
                        expires: now + 10000,
                        blinkStart: now + 7000,
                        rotation: 0,
                        special: true
                    };
                    
                    validPosition = !snake.some(segment => 
                        Math.abs(segment.x - newFood.x) < 1.5 && 
                        Math.abs(segment.y - newFood.y) < 1.5
                    );
                }
                
                food.push(newFood);
                specialFoodActive = true;
                lastSpecialFoodLevel = level;
                return;
            }
            
            // Cria comida normal
            if (food.length < 2) {
                const normalFoodTypes = FOOD_TYPES.filter(f => !f.special);
                const foodType = normalFoodTypes[Math.floor(Math.random() * normalFoodTypes.length)];
                
                let newFood;
                let validPosition = false;
                
                while (!validPosition) {
                    newFood = {
                        x: Math.floor(Math.random() * arenaSize),
                        y: Math.floor(Math.random() * arenaSize),
                        type: foodType,
                        expires: now + 20000,
                        blinkStart: now + 15000,
                        rotation: 0,
                        special: false
                    };
                    
                    validPosition = !snake.some(segment => 
                        Math.abs(segment.x - newFood.x) < 1.5 && 
                        Math.abs(segment.y - newFood.y) < 1.5
                    );
                }
                
                food.push(newFood);
            }
        }
        
        // Atualiza HUD
        function updateHUD() {
            scoreElement.textContent = score;
            levelElement.textContent = level;
            
            if (invincible) {
                const remaining = Math.max(0, (invincibleEndTime - Date.now()) / 1000).toFixed(1);
                invincibleTimeElement.textContent = remaining;
                invincibleTimer.style.display = 'block';
            } else {
                invincibleTimer.style.display = 'none';
            }
        }
        
        // Atualiza a cor da cobra baseado no nível
        function updateSnakeColor() {
            const colorIndex = Math.min(level - 1, SNAKE_COLORS.length - 1);
            currentSnakeColor = SNAKE_COLORS[colorIndex];
        }
        
        // Inicia animação de level up
        function startLevelUpAnimation() {
            if (isLevelUpAnimation) return;
            
            isLevelUpAnimation = true;
            levelUpAnimationEndTime = Date.now() + 2000;
            levelUpColorIndex = 0;
            
            levelUpSound.currentTime = 0;
            levelUpSound.play();
            
            levelUpAnimationInterval = setInterval(() => {
                levelUpColorIndex = (levelUpColorIndex + 1) % LEVEL_UP_COLORS.length;
            }, 100);
        }
        
        // Finaliza animação de level up
        function endLevelUpAnimation() {
            isLevelUpAnimation = false;
            clearInterval(levelUpAnimationInterval);
            updateSnakeColor();
        }
        
        // Reduz o tamanho da cobra
        function shrinkSnake() {
            const newLength = Math.max(3, Math.floor(snake.length / 2));
            snake = snake.slice(0, newLength);
            snakeSegments = snakeSegments.slice(0, newLength);
            
            specialFoodSound.currentTime = 0;
            specialFoodSound.play();
        }
        
        // Loop principal do jogo
        function gameTick() {
            if (!gameActive) return;
            
            const now = Date.now();
            
            if (isLevelUpAnimation && now > levelUpAnimationEndTime) {
                endLevelUpAnimation();
            }
            
            direction = nextDirection;
            
            const head = {...snake[0]};
            
            switch (direction) {
                case 'UP':
                    head.y -= 1;
                    head.angle = -Math.PI/2;
                    break;
                case 'DOWN':
                    head.y += 1;
                    head.angle = Math.PI/2;
                    break;
                case 'LEFT':
                    head.x -= 1;
                    head.angle = Math.PI;
                    break;
                case 'RIGHT':
                    head.x += 1;
                    head.angle = 0;
                    break;
            }
            
            if (head.x < 0) head.x = arenaSize - 1;
            if (head.x >= arenaSize) head.x = 0;
            if (head.y < 0) head.y = arenaSize - 1;
            if (head.y >= arenaSize) head.y = 0;
            
            snake.unshift(head);
            
            let foodEaten = false;
            for (let i = 0; i < food.length; i++) {
                const dist = Math.sqrt(
                    Math.pow(head.x - food[i].x, 2) + 
                    Math.pow(head.y - food[i].y, 2)
                );
                
                if (dist < 0.8) {
                    applyFoodEffect(food[i]);
                    food.splice(i, 1);
                    foodEaten = true;
                    break;
                }
            }
            
            if (!foodEaten) {
                snake.pop();
            } else {
                createFood();
            }
            
            if (!invincible) {
                for (let i = 4; i < snake.length; i++) {
                    const dist = Math.sqrt(
                        Math.pow(head.x - snake[i].x, 2) + 
                        Math.pow(head.y - snake[i].y, 2)
                    );
                    
                    if (dist < 0.7) {
                        gameOver();
                        return;
                    }
                }
            }
            
            if (invincible && now >= invincibleEndTime) {
                invincible = false;
            }
            
            if (now - lastTickTime > 5000) {
                createFood();
                lastTickTime = now;
            }
            
            updateHUD();
        }
        
        // Aplica efeito da comida
        function applyFoodEffect(foodItem) {
            score += foodItem.type.points;
            
            switch (foodItem.type.effect) {
                case 'grow':
                    const tail = {...snake[snake.length-1]};
                    for (let i = 0; i < 3; i++) {
                        snake.push({...tail});
                    }
                    break;
                case 'speed_up':
                    speed = Math.min(4, speed + 0.3);
                    clearInterval(gameLoop);
                    gameLoop = setInterval(gameTick, TICK_RATE_BASE / speed);
                    break;
                case 'invincible':
                    invincible = true;
                    invincibleEndTime = Date.now() + 8000;
                    break;
                case 'shrink':
                    shrinkSnake();
                    specialFoodActive = false;
                    break;
            }
            
            const newLevel = Math.floor(score / 80) + 1;
            if (newLevel > level) {
                level = newLevel;
                startLevelUpAnimation();
            }
        }
        
        // Game over
        function gameOver() {
            gameActive = false;
            clearInterval(gameLoop);
            clearInterval(levelUpAnimationInterval);
            
            finalScoreElement.textContent = score;
            finalLevelElement.textContent = level;
            gameOverScreen.style.display = 'flex';
            
            if (isMobile) {
                mobileControls.style.display = 'none';
            }
        }
        
        // Animação suave da cobra
        function smoothRender() {
            if (!gameActive) {
                requestAnimationFrame(smoothRender);
                return;
            }
            
            const interpolationFactor = 0.2;
            for (let i = 0; i < snake.length; i++) {
                snakeSegments[i] = snakeSegments[i] || {x: snake[i].x, y: snake[i].y, angle: snake[i].angle};
                snakeSegments[i].x += (snake[i].x - snakeSegments[i].x) * interpolationFactor;
                snakeSegments[i].y += (snake[i].y - snakeSegments[i].y) * interpolationFactor;
                
                let angleDiff = snake[i].angle - snakeSegments[i].angle;
                if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
                if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
                
                snakeSegments[i].angle += angleDiff * interpolationFactor * 0.5;
            }
            
            render();
            
            if (gameActive) {
                requestAnimationFrame(smoothRender);
            }
        }
        
        // Renderiza o jogo
        function render() {
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2
            );
            gradient.addColorStop(0, '#0a0a2a');
            gradient.addColorStop(1, '#000011');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = canvas.width / arenaSize;
            ctx.strokeStyle = 'rgba(100, 100, 200, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= arenaSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
            
            ctx.strokeStyle = 'rgba(0, 200, 255, 0.3)';
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, canvas.width-4, canvas.height-4);
            
            const now = Date.now();
            food.forEach(f => {
                f.rotation += 0.02;
                
                let drawFood = true;
                if (f.blinkStart && now > f.blinkStart) {
                    drawFood = Math.floor(now / 100) % 2 === 0;
                }
                
                if (drawFood) {
                    const centerX = (f.x + 0.5) * cellSize;
                    const centerY = (f.y + 0.5) * cellSize;
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, f.type.size * 2, 0, Math.PI * 2);
                    const glowGradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, f.type.size * 2
                    );
                    glowGradient.addColorStop(0, f.type.glow);
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.globalAlpha = 0.4;
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(f.rotation);
                    
                    if (f.type.special) {
                        ctx.beginPath();
                        const spikes = 5;
                        const outerRadius = f.type.size;
                        const innerRadius = f.type.size * 0.5;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = Math.PI * i / spikes;
                            const x = radius * Math.cos(angle);
                            const y = radius * Math.sin(angle);
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                    } else {
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = i * Math.PI / 3;
                            const radius = i % 2 === 0 ? f.type.size : f.type.size * 0.7;
                            const x = radius * Math.cos(angle);
                            const y = radius * Math.sin(angle);
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                    }
                    
                    ctx.fillStyle = f.type.color;
                    ctx.shadowColor = f.type.glow;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.restore();
                }
            });
            
            snakeSegments.forEach((segment, index) => {
                const segmentSize = cellSize * 0.9;
                const centerX = (segment.x + 0.5) * cellSize;
                const centerY = (segment.y + 0.5) * cellSize;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(segment.angle);
                
                ctx.beginPath();
                ctx.ellipse(0, 0, segmentSize/2, segmentSize/3, 0, 0, Math.PI * 2);
                
                if (isLevelUpAnimation) {
                    const color = LEVEL_UP_COLORS[levelUpColorIndex];
                    const rgb = hexToRgb(color);
                    
                    const gradient = ctx.createLinearGradient(-segmentSize/2, 0, segmentSize/2, 0);
                    gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.8)`);
                    gradient.addColorStop(1, `rgba(${Math.max(0, rgb.r-50)}, ${Math.max(0, rgb.g-50)}, ${Math.max(0, rgb.b-50)}, 0.8)`);
                    ctx.fillStyle = gradient;
                    ctx.shadowColor = color;
                } else {
                    const intensity = 1 - (index / snakeSegments.length * 0.8);
                    const gradient = ctx.createLinearGradient(-segmentSize/2, 0, segmentSize/2, 0);
                    gradient.addColorStop(0, `rgba(${hexToRgb(currentSnakeColor.primary).r}, ${hexToRgb(currentSnakeColor.primary).g}, ${hexToRgb(currentSnakeColor.primary).b}, 0.8)`);
                    gradient.addColorStop(1, `rgba(${hexToRgb(currentSnakeColor.secondary).r}, ${hexToRgb(currentSnakeColor.secondary).g}, ${hexToRgb(currentSnakeColor.secondary).b}, 0.8)`);
                    ctx.fillStyle = gradient;
                    ctx.shadowColor = currentSnakeColor.secondary;
                }
                
                if (index === 0 && invincible) {
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 20;
                } else {
                    ctx.shadowBlur = 10;
                }
                
                ctx.fill();
                
                if (index === 0) {
                    ctx.beginPath();
                    ctx.arc(segmentSize/2 - 5, 0, 5, 0, Math.PI * 2);
                    ctx.fillStyle = isLevelUpAnimation ? LEVEL_UP_COLORS[levelUpColorIndex] : currentSnakeColor.secondary;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(segmentSize/2 - 10, -8, 3, 0, Math.PI * 2);
                    ctx.arc(segmentSize/2 - 10, 8, 3, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                } else {
                    ctx.strokeStyle = isLevelUpAnimation ? 
                        LEVEL_UP_COLORS[levelUpColorIndex] : 
                        `rgba(${hexToRgb(currentSnakeColor.secondary).r}, ${hexToRgb(currentSnakeColor.secondary).g}, ${hexToRgb(currentSnakeColor.secondary).b}, 0.7)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, segmentSize/2 - 5, segmentSize/3 - 3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        // Converte hex para RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        // Event listeners para teclado
        document.addEventListener('keydown', (e) => {
            if (!gameActive && e.key === ' ') {
                initGame();
                return;
            }
            
            switch (e.key) {
                case 'ArrowUp':
                    if (direction !== 'DOWN') nextDirection = 'UP';
                    break;
                case 'ArrowDown':
                    if (direction !== 'UP') nextDirection = 'DOWN';
                    break;
                case 'ArrowLeft':
                    if (direction !== 'RIGHT') nextDirection = 'LEFT';
                    break;
                case 'ArrowRight':
                    if (direction !== 'LEFT') nextDirection = 'RIGHT';
                    break;
            }
        });
        
        // Event listeners para controles touch
        upBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (direction !== 'DOWN') nextDirection = 'UP';
        });
        
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (direction !== 'RIGHT') nextDirection = 'LEFT';
        });
        
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (direction !== 'LEFT') nextDirection = 'RIGHT';
        });
        
        downBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (direction !== 'UP') nextDirection = 'DOWN';
        });
        
        // Também adiciona eventos de click para dispositivos que não suportam touch
        upBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (direction !== 'DOWN') nextDirection = 'UP';
        });
        
        leftBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (direction !== 'RIGHT') nextDirection = 'LEFT';
        });
        
        rightBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (direction !== 'LEFT') nextDirection = 'RIGHT';
        });
        
        downBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (direction !== 'UP') nextDirection = 'DOWN';
        });
        
        // Eventos de UI
        startGameBtn.addEventListener('click', () => {
            playMenuSound();
            setTimeout(initGame, 300);
        });
        
        difficultyBtn.addEventListener('click', showDifficultyOptions);
        backBtn.addEventListener('click', hideDifficultyOptions);
        
        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => selectDifficulty(btn));
        });
        
        instructionsBtn.addEventListener('click', () => {
            playMenuSound();
            alert("INSTRUÇÕES:\n\nUse as setas do teclado ou os botões na tela (em celulares) para controlar a serpente.\n\nColete os itens coloridos para ganhar pontos e efeitos especiais:\n- Azul: Crescer\n- Amarelo: Escudo temporário\n- Verde: Aumentar velocidade\n- Rosa: Reduzir tamanho\n\nEvite colidir com o próprio corpo!");
        });
        
        restartBtn.addEventListener('click', () => {
            playMenuSound();
            setTimeout(initGame, 300);
        });
        
        // Ajusta o tamanho do canvas quando a janela é redimensionada
        window.addEventListener('resize', () => {
            detectMobile();
            render();
        });
        
        // Inicia o jogo com a tela de loading
        simulateLoading();
    </script>
</body>
</html>